---
title: "【内部品質向上シリーズ】アーキテクチャ編"
emoji: "👋"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: []
published: false
---
# 主な元ネタ

[Clean Architecture  達人に学ぶソフトウェアの構造と設計](https://tatsu-zine.com/books/clean-architecture)

↑よく間違われがち（自分もその一人だった）なのですが、この本は良いアーキテクチャ一般の話をしていて、オニオンアーキテクチャと並んで語られるドーナツ型の図のクリーンアーキテクチャの話だけをしているわけではないです。

[達人プログラマー（第2版） 熟達に向けたあなたの旅 | Ohmsha](https://www.ohmsha.co.jp/book/9784274226298/)

# ソフトウェアアーキテクチャの重要性

（[「ソフトウェアアーキテクチャ」という言葉には明確な定義がない](https://ja.wikipedia.org/wiki/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3#:~:text=%E3%81%9F%E3%81%A0%E3%81%97%E3%80%81%E4%BB%8A%E3%81%BE%E3%81%A7%E3%81%AE%E3%81%A8%E3%81%93%E3%82%8D%E3%80%8C%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3%E3%80%8D%E3%81%A8%E3%81%84%E3%81%86%E7%94%A8%E8%AA%9E%E3%81%AB%E9%96%A2%E3%81%97%E3%81%A6%E3%80%81%E4%B8%87%E4%BA%BA%E3%81%8C%E5%90%88%E6%84%8F%E3%81%97%E3%81%9F%E5%8E%B3%E5%AF%86%E3%81%AA%E5%AE%9A%E7%BE%A9%E3%81%AF%E5%AD%98%E5%9C%A8%E3%81%97%E3%81%AA%E3%81%84)ので、ざっくりと「ソフトウェア開発における設計のこと」と思ってください）

ソフトウェアを「（一度だけ）動かす」ことはさほど難しくない。

一方で、ソフトウェアを「正しくする」ことは難しい。

ここでいう「正しい」とは、メンテナンスにかかるコストが低いとか、新しい機能を追加しやすいとか、それによりかかる人員が少なくなるとか。

> ソフトウェアアーキテクチャの目的は、求められるシステムを構築・保守するために必要な人材を最小限に抑えることである。
> 

（『Clean Architecture 達人に学ぶソフトウェアの構造と設計』より）

# プログラミングパラダイムの歴史からわかること

アーキテクチャをなんたるかを知るために、歴史を見ていきましょう。

（ここで紹介するパラダイムを採用することがいいアーキテクチャ、という話**ではなく**、それぞれのパラダイムが何を提唱してきたのかということを知ります）

## 構造化プログラミングの誕生

1960年代ごろまで、プログラミングは goto 文が主流だったのをご存知でしょうか。

goto という命令は、「◯行目の処理に飛ぶ（ジャンプする）」という命令で、プログラムの実行フローを無秩序に飛び回らせることができるものでした。
そのため、大規模なプログラムや複雑な処理が必要になると、読みづらく、理解が難しく、バグを修正するのが非常に困難でした。

こうした背景の中で、プログラムの構造をより明確にし、理解や保守を容易にするために「構造化プログラミング」という考え方が登場しました。

構造化プログラミングとは、以下の構造だけプログラミングを行う（＝**gotoを使わない**）手法です。

1. 順次…上から下に、順番に実行する（当たり前）
2. 選択…条件によって分岐させる（ `if`, `switch` ）
3. 反復…条件が満たされるまで繰り返す（ `for` , `while` ）

これによりプログラムに秩序がもたらされ、認識・管理しやすくなった。

https://qiita.com/iHdkz/items/de8a0bf1a3d6c6c24215

https://www.youtube.com/watch?v=8y9hCQpN40A

https://ja.wikipedia.org/wiki/%E6%A7%8B%E9%80%A0%E5%8C%96%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0

## オブジェクト指向プログラミング

オブジェクト指向（OO）の解釈には様々ありますが、ここでは『Clean Architecture 達人に学ぶソフトウェアの構造と設計』の説明から、アーキテクチャにおいて重要な以下の点を引用する。

> OOとは「ポリモーフィズムを使用することで、システムにあるすべてのソースコードの依存関係を絶対的に制御する能力」である。
> 

ポリモーフィズムは、異なるクラスのオブジェクトが同じインターフェースを共有し、それsぞれ異なる方法で実装することを指します。この特徴により、依存性逆転が実現できます。

依存性逆転の法則についてはずんださんの勉強会でも話されているので割愛します。

[backend に潜む Onion Architecture の影](https://www.notion.so/backend-Onion-Architecture-9cc7ecab2dc442449f224c64862d5b13?pvs=21) 

データベースのコードをビジネスルールに依存させることができるようになる。

## 関数型プログラミング

関数型プログラミングは、「状態を持たない」「代入をしない」プログラミング手法です。

まず、関数型でない（手続き型の）プログラミングでは、変数に値を代入していって、状態を変えていく手法です。

```tsx
// i の状態が変化していく
for (let i = 0; i < 10; i++) {
  console.log(i);
}
```

一方、関数型プログラミングでは状態を変更しません。「0から9のリスト」を取得して処理するという考え方です。

（以下は関数型プログラミング言語、Clojureのコード例）

```clojure
(println (range 0 10))
```

関数型プログラミング言語では変数の再代入がそもそもできません。

このように状態の変化がなくなると、「このときこの変数の状態はどうなっているんだ…？」と考えることがなくなります。この特徴は「参照透過性」にも繋がります。参照透過性とは、同じ値を与えたら同じ結果が返ってくるような性質のことです。

> 参照透過性とは、同じ値を与えたら返り値も必ず同じになるような性質である[[1]](https://ja.wikipedia.org/wiki/%E9%96%A2%E6%95%B0%E5%9E%8B%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0#cite_note-%E5%90%8D%E5%89%8D%E3%81%AA%E3%81%97-1-1)。参照透過性を持つことは、その関数が**状態を持たない**ことを保証する[[4]](https://ja.wikipedia.org/wiki/%E9%96%A2%E6%95%B0%E5%9E%8B%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0#cite_note-%E5%90%8D%E5%89%8D%E3%81%AA%E3%81%97-4-4)。状態を持たない数学的な関数は、並列処理を実現するのに適している[[4]](https://ja.wikipedia.org/wiki/%E9%96%A2%E6%95%B0%E5%9E%8B%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0#cite_note-%E5%90%8D%E5%89%8D%E3%81%AA%E3%81%97-4-4)。関数型プログラミング言語の内で、全ての関数が参照透過性を持つようなものを純粋関数型プログラミング言語という[[4]](https://ja.wikipedia.org/wiki/%E9%96%A2%E6%95%B0%E5%9E%8B%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0#cite_note-%E5%90%8D%E5%89%8D%E3%81%AA%E3%81%97-4-4)。
> 

https://ja.wikipedia.org/wiki/%E9%96%A2%E6%95%B0%E5%9E%8B%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0

## パラダイムからわかること

パラダイムが与えたのは「何をすべきでないか」である

- 構造化プログラミングは、処理の書き方に規律を課し、goto（無秩序なジャンプ）を禁止した。
- オブジェクト指向プログラミングにより、依存関係を制御できるようになった。関数を直接参照することを禁止した。
- 関数型プログラミングでは代入に規律を課し、状態を持つことを禁止した。

<aside>
ℹ️

アーキテクチャを定めていくということは、「すべきでないこと」を決めて、実装を制限していくこと

</aside>

# よい設計とは

> よい設計は悪い設計よりも変更しやすい
> 

『達人プログラマー』より

> アーキテクチャの形状の目的は、そこに含まれるソフトウェアシステムの開発・デプロイ・運用・保守を容易にすることである
> 

> それらを容易にするための戦略は、できるだけ長い期間、できるだけ多く選択肢を残すことである。
> 

> 「残すべき選択肢」とは何だろうか？　それは**重要ではない詳細**である。
> 

『Clean Architecture 達人に学ぶソフトウェアの構造と設計』より

どのデータベースシステムを採用するか、どんなインターフェース（REST, GraphQL, …）を採用するか、といったことは「詳細」にあたる。
