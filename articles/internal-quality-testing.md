---
title: "【内部品質向上シリーズ】テスト編"
emoji: "👻"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: []
published: false
---
<aside>
⚙

### 【内部品質向上シリーズ】とは

ソフトウェアを使う人にとっての品質を示す「外部品質」に対して、開発する人にとっての品質を示す「内部品質」を向上していくことで、メンテナンス性の高いソフトウェアにして、開発スピードを上げていこうというシリーズ。

そもそも「コードの品質」「内部品質」とは、みたいなところはt_wadaさんの講演がわかりやすいです。

[[GS-1-2] 『質とスピード』特別編 〜 現代のソフトウェア開発にキャッチアップしていくヒント〜） | AWS Dev Day 2023 Tokyo #AWSDevDay](https://www.youtube.com/watch?v=-yPPfe13bb0)

</aside>

- 目次

# 主な元ネタ

『単体テストの考え方/使い方』を読んだので主にそこからの話をしたい。

[単体テストの考え方/使い方|マイナビブックス](https://book.mynavi.jp/ec/products/detail/id=134252)

[開発生産性の観点から考える自動テスト / タワーズ・クエスト株式会社 和田 卓人](https://www.youtube.com/watch?v=ueqjypYJnxk)

[【DXD2024】望ましい自動テストとは: どのようなテストが開発生産性と開発者体験を共に高めるのか（7/16 16:00〜16:45）](https://www.youtube.com/watch?v=8MiWDWAG1XQ)

↑のレポート記事: https://levtech.jp/media/article/column/detail_496/

## その他、おすすめの資料など

https://www.amazon.co.jp/%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89%E9%96%8B%E7%99%BA%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AE%E3%83%86%E3%82%B9%E3%83%88%E5%85%A5%E9%96%80-%E4%BB%8A%E3%81%8B%E3%82%89%E3%81%A7%E3%82%82%E7%9F%A5%E3%81%A3%E3%81%A6%E3%81%8A%E3%81%8D%E3%81%9F%E3%81%84%E8%87%AA%E5%8B%95%E3%83%86%E3%82%B9%E3%83%88%E6%88%A6%E7%95%A5%E3%81%AE%E5%BF%85%E9%A0%88%E7%9F%A5%E8%AD%98-%E5%90%89%E4%BA%95-%E5%81%A5%E6%96%87/dp/4798178187

https://www.youtube.com/watch?v=zEf7ImUkyl4

# そもそもテストの役割って…

岸の言葉でまとめると、**「プロダクトコードを変えるためのもの」**です。

（以下は『単体テストの考え方/使い方』からの要約）

コードベースは成長とともに劣化していきます。そのため、リファクタリングなどの処置を加えていく必要があります。

それを助けるのがテストです。テストがあることで、機能追加やリファクタリングをしたときに既存の機能が正しく振る舞うこと（リグレッションがないこと）を確信できるようになります。

テストの存在そのものではなく、テストが存在することによってコードを書き換えられる、という点が重要です。

![https://www.youtube.com/watch?v=ueqjypYJnxk](https://prod-files-secure.s3.us-west-2.amazonaws.com/53c545b9-40b0-40d4-b82f-86ff1afd44dd/d2dd6f21-1782-455e-98fe-1337b10750b6/%E9%96%8B%E7%99%BA%E7%94%9F%E7%94%A3%E6%80%A7%E3%81%AE%E8%A6%B3%E7%82%B9%E3%81%8B%E3%82%89%E8%80%83%E3%81%88%E3%82%8B%E8%87%AA%E5%8B%95%E3%83%86%E3%82%B9%E3%83%88___%E3%82%BF%E3%83%AF%E3%83%BC%E3%82%B9%E3%82%99%E3%83%BB%E3%82%AF%E3%82%A8%E3%82%B9%E3%83%88%E6%A0%AA%E5%BC%8F%E4%BC%9A%E7%A4%BE_%E5%92%8C%E7%94%B0_%E5%8D%93%E4%BA%BA_40-46_screenshot.png)

https://www.youtube.com/watch?v=ueqjypYJnxk

# テストには「良いテスト」と「悪いテスト」があることを知る

テストはあればあるほどいいというものではありません。質の善し悪しがあります。

そのため、**質の善し悪しを見分けられる**ことが、テストを作成することと同じくらい重要です。

その上で、質の悪いテストコードを、質の良いテストコードにリファクタできる必要があります。

## レビュアーの立場でも気をつける

他の人のコードをレビューするとき、ちゃんとテストコードをレビューしていますか？

テストの質の善し悪しを実装者が意識することはもちろんのこと、レビュアーも意識してレビューしましょう。

# 大前提：すべてのコードは負債である

すべてのコードは負債になります。テストコードもプロダクトコードも同様で、かつそれがどんなに価値のある機能だとしても。

コードが存在し、その量が増えるほど、メンテナンスコストが増えていくものです。

そのため、**そのコードには残すだけの価値があるのか**を意識することが重要です。

同じメリットを生むなら最小限のコード量になるようリファクタし、メリットがない（少ない）のであれば削除を検討します。

# 質の悪いテストの特徴

質の悪いテストには主に３つのタイプがあります。

- 間違った理由で失敗する（偽陽性）
- リグレッションを検出できない（偽陰性）
- 簡単に保守できない（メンテナンスコスト）

## 間違った理由で失敗する（偽陽性を生む）テスト

この中にさらに２種類あります。

- 脆いテスト（fragile test）…ちょっとした修正で壊れるテスト
- 信頼不能テスト（flaky test） …何も変えていないのに壊れるテスト

### 脆いテスト（fragile test）

詳細までテストしすぎていたり、モックを使いまくっていたりすると起こりやすいです。

以下の記事がわかりやすかったので詳細は割愛。
https://www.agile-studio.jp/post/twop-tdd-fragile-test

### 信頼不能テスト（flaky test）

実行順序に依存していたり、E2Eで読み込みにかかる時間がまちまちだったりするときに起こります。

ずんださんがbiz勉強会で話していたので、こちらも詳細は割愛。

[たまに落ちるテストができがちなところ](https://www.notion.so/130c5cd9cfb2800c95f5d8376ff7eaa7?pvs=21) 

以下の記事も参考に。

https://www.agile-studio.jp/post/twop-tdd-erratic-test

## リグレッションを検出できない（偽陰性を生む）テスト

https://levtech.jp/media/article/column/detail_496/

３種類あります。

- 空振りテスト
- 自作自演テスト
- カバレッジ不足とテスト不足

### 空振りテスト

そもそもテストが実行されてなかったよ、っていうパターン。そんなバカなと思うかもしれないですが、結構あります。

たとえば、

- 設定ファイルの対象が `**/*.test.ts` なのに `sample.spec.ts` って名前で作成しちゃってた…
- 開発中に一時的に `test.skip` してそのままにしちゃってた…

とか。

**「テストが落ちることを確認する」**というのは結構重要です。テストファイルを作成した初手など、あえて失敗するはずのテストコードを動かしてみて、実行されているか確認するとよいです。

テストを書いた後は、プロダクトコードの一部をコメントアウトしてみて、「この処理がなかったらテストが落ちるはず」を試してみるとよいです。

### 自作自演テスト

プロダクトコードと同じことやってるんだからそりゃ成功するだろ、っていうテスト。

（結構やってる人多いです）

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/53c545b9-40b0-40d4-b82f-86ff1afd44dd/c09a1c15-302e-4e39-b89f-953585a05e6a/image.png)

> **和田：*このテストは成功しますが、プロダクトコードにはバグがあります***。
> 
> 
> JavaScriptのNumber型は、浮動小数点数なので、端数が出ます。1円未満の端数というバグが出る。でもこのテストは成功しちゃう。なぜか？　プロダクトコードの方の期待値も、同じ計算式で計算しているからです。
> 
> このような***「プロダクトコードで望む振る舞いを、テストコードで再現しており、テストになっていない」***というパターンは、現場で本当によくあるので、テストコードを書く際に注意すべきポイントです。
> 

**テストコード内で「計算」とか「条件分岐」とかが発生していたら危険信号**です。

基本的にテストで期待する値はプリミティブ（計算後の数値など）を使うようにしましょう。

テストコードに条件分岐を入れるのもアンチパターンです。

https://azukiazusa.dev/blog/avoid-writing-conditional-branches-in-the%E2%80%93test-code/

### カバレッジ不足とテスト不足

> カバレッジ不足とは、書かれるべきテストが書かれていないことです。テストすべき行にテストがなければ、その行にバグがあっても、テストが成功してしまいますよね。これはコードカバレッジツールを通して可視化し、倒すことができます。
> 
> 
> 手強いのはテスト不足です。これは、書かれるべきコードが書かれていない状態です。コードが書かれていない、つまり人間の仕様レベルで把握できていない時には、コードが書かれていないからテストももちろん書かれていない。このためテスト全体は通ってしまいます。人間が把握できていない。こいつがラスボスです。
> 

**「人間が仕様を把握する」**っていうのが最重要。

## 簡単に保守できない（メンテナンスコストが高い）テスト

2つの観点があります。

### 意図が理解できないテスト

テストは実行できればいいと思わず、人間が読んで理解できることを意識しましょう。

以下の記事も参考。

https://www.agile-studio.jp/post/twop-tdd-obscure-test

### 実行することが難しいテスト

プロセス外依存（データベースなど）を必要とする場合、データベースの起動や接続の設定が必要となるため、メンテナンスコストが上がる。

もちろんそれが必要なテストであれば仕方ないが、データベースなしで実現できるテストであればそうしたほうがよい。

# 質の良いテストとは

### **4つの柱**

by『単体テストの考え方/使い方』

1. リグレッションに対する保護
    - 既存の機能が動かなくなったときに、ちゃんと検出できること
2. リファクタリングへの耐性
    - 偽陽性が生まれるテストコードの場合、表現上の振る舞いが変わっていないのに失敗してしまう（オオカミ少年になってしまう）ため、「リファクタリングしただけで落ちる」ということに繋がる。
    - 実装の詳細ではなく、最終的な結果のみを確認して、リファクタリングしただけ（＝表面上の振る舞いが変わっていない）なのであればテスト結果が変わらないのが望ましい。
3. 迅速なフィードバック
    - 実行時間が短いこと。
4. 保守のしやすさ
    - テストケースの理解しやすさ。＝テストコードを修正しやすいか。
    - テストを実行することの簡単さ。
        - jestコマンドだけで動くか、Firebase Emulatorが必要か、Dockerが必要か…など

ただし、保守以外の3つの観点は互いに排反（トレードオフ）であるため、適材適所。

例えば、E2Eテストは実行時間が長い代わりに、リグレッションに対する保護やリファクタリングへの耐性は高い。

# その他雑多な話

## AAAパターン

Arrange-Act-Assert という、テストコードの段階の分け方。世に多くの記事があるので詳細は割愛。知っておくと読みやすいテストコードが書けるはず。

https://tech.pepabo.com/2021/08/23/writing-unit-test-with-aaa

Given-When-Thenという呼び方もあるらしい。

https://zenn.dev/m10maeda/articles/gwt-might-feel-more-natural-than-3a-for-ui-testing

- AAAパターンに分けると、良し悪しを判断しやすくなる
    
    （『単体テストの考え方/使い方』第3章）
    
    - 同じフェーズが複数（Actが複数、Assertが複数など）ある場合、テストを分けたほうが良い。複数の振る舞いを検証するのは統合テストのやること。
    - テストでは、if文（分岐）を使うべきでない。1つのテストケースで複数のことを検証しようとしてしまっている。
    - 基本的にはArrangeが多くなる。
    - Actが1行を超す場合は注意。本来一つのメソッドとしてまとめるべき機能を、分離してしまっている（カプセル化に失敗している）ため。
    - Assertは必ずしも1つである必要はない。「1単位の振る舞い」によって複数の結果が生じることはあるため、それを調べるなら自然なこと。ただし、多くなりすぎていたら、コードの抽象化がうまくいっていないかもしれないので注意。

## テスト名は日本語で書こう

https://www.youtube.com/watch?v=TD64QRyRXHw&pp=ygUi5a6f6Le1IOODpuODi-ODg-ODiOODhuOCueODiOWFpemWgA%3D%3D

https://speakerdeck.com/panda_program/shi-jian-yunitutotesutoru-men?slide=65 （65ページ目）

『JUnit実践入門』にも出てくるとのこと。

（以下はPHPの話なので関数名になっているが、JSではdescribeやtestの名前部分にあたる）

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/53c545b9-40b0-40d4-b82f-86ff1afd44dd/f1dd297b-1a40-4353-8b0a-ba893d6f6191/image.png)

## **単体テストの命名の考え方**

by『単体テストの考え方/使い方』

- 指針
    - 厳格な命名規則に縛られない
    - 非開発者に伝わるようにする
        - コードではなく、アプリケーションの振る舞いをテストしているから
- Badパターン
    - 実装の詳細によってしまっている
    - 例： `IsDeliveryVilid_不正な日付_Falseを返す` （`{テスト対象メソッド}_{事前条件}_{想定する結果}`）
- 改善パターン
    - `不正な日付が指定された配達は不正だとみなされるべきである`
        - 非開発者にも伝わる
        - テスト対象のメソッド名が含まれない
        - しかし「不正ってどういうこと？」が明確でない
    - `過去の日付が指定された配達は不正だとみなされるべきである`
        - どういうものが不正かわかるようになった
    - `過去の日付が指定された配達は不正とすべきである`
    - `過去の日付が指定された配達は不正である`
        - 振る舞いについての事実を伝えるものなので、希望や要望は含まなくて良い

## マッチャーに詳しくなろう

意図した挙動をテストコードとして表現できるように、アサーションの手段を知っておくとよい。

例：[jest  `.toMatchObject()` のススメ](https://www.notion.so/jest-toMatchObject-160c5cd9cfb2807ba932df489a6fef62?pvs=21) 

## リポジトリのテストはない方がよい

by『単体テストの考え方/使い方』

データベースの操作を抽象化したリポジトリと呼ばれるパターンについて。

- 保守コストが高く、退行に対する保護もあまり備わらない。
    - 保守コストの高さ：プロセス外依存（データベース）を扱うコードであり、これは統合テストと同じくらいのコストの高さになる
    - 退行に対する保護の弱さ：統合テストでカバーできる範囲しかカバーされないため、新たな価値を産まない。
- そのため、テストスイートの価値を下げることになるので、ないほうがよく、統合テストの一部に組み込むのがよい。

「あっても価値が低い」のではなく「ないほうがよい」というのもポイント。

メリットがないだけでなく、存在することによってメンテナンスコストがかかるため、なくしたほうがよいとのこと。

# 意識

## テストには人間の願いを書く

プロダクトコードからポンと生まれるものではなく、その関数（ひいてはそのアプリケーション）がどんな機能を持っていてほしいかを書くもの。

どれだけ仕様設計ができているかが重要になる。

命名について「非開発者に伝わるようにする」という説明があった通り、アプリケーションの振る舞いを記述するのであって、実装都合で書くものではない。

## テストが書きにくい場合、プロダクトコードの質が悪い

テストは、どんなプロダクトコードに対してもポンと生み出せるわけではありません。
テストコードの書きやすさは、対象となるプロダクトコードの質に依存します。
**テストが書きにくい場合、プロダクトコード側の変更を検討**してください。
（これも冒頭の「テストはプロダクトコードを変えるためのもの」という役割の一部です）

だからこそ、テストを先に書く進め方（テスト駆動開発）がよいやり方として広まっています。

特に生成AIがコードを書いてくれる現代、テストコードを人間が設計し、それに合わせて実装させるという方が理想的かもしれません。

（どう動いてほしいかという願いは人間だけが持っているので）

ちなみにこれはロジックのテストだけでなく、UIのテストにも言えることです。

PlaywrightやStorybook test、react-testing-libraryでコンポーネントのテストをしようとしたとき、あるボタン要素の特定が難しいと感じたら、人間のユーザーにとってもそのボタンを見つけるのが難しいかもしれません。

例えば、同じページ内に「キャンセル」と書かれたボタンが何個もあったら（しかもそれが別の機能だったりしたら）、目的のボタンを人間が見つけるのもテストで記述するのも大変ですね。

### アクセシビリティとテストの書きやすさは比例しやすいという話

- https://zenn.dev/takepepe/articles/improve-a11y-and-testing
    
    > 「コンポーネントに含まれる全ての link ロール要素の 2 番目」という、意味をもたないクエリであり、有意義なものとは言えません。冒頭に a11y tree で確認したとおり、テストコードからも「アクセシブルではない」ことが滲み出ていますね。
    > 
    > 
    > ```tsx
    > const href = "https://testing.example.com/articles/2";
    > const links = screen.getAllByRole("link");
    > expect(links[1]).toHaveAttribute("href", href);
    > ```
    > 
    > このテストコードは、施した a11y 改善により、以下の様に修正することができます。region ロールをアクセシブルネーム（タイトルそのもの）で絞り込み、含まれる link を検証しています。
    > 
    > ```tsx
    > const href = "https://testing.example.com/articles/2";
    > const title = "React18 の useId で a11y対応する";
    > const region = screen.getByRole("region", { name: title });
    > expect(within(region).getByRole("link")).toHaveAttribute("href", href);
    > ```
    > 
- https://smarthr.design/accessibility/check-list/accessible-name/
    
    > 
    > 
    > 1. **視覚障害のあるユーザー**: スクリーンリーダーがアクセシブルネームを読むことで、画面が見えない状況でもフォームの各部分を正しく理解し、操作できます。
    > 2. **開発テストでの活用**: アクセシブルネームが設定されていると、自動テストや手動テストにおいて要素を識別しやすくなります。これにより、テストケースの作成や実行が容易になり、開発プロセス全体の効率が向上します。例えば、UIテストの自動化ツールは、明確なアクセシブルネームを使用して正確に要素を特定し、操作や検証を行なうことができます。

## テストはドキュメントになるように書く

テストを見たら、そのテスト対象（関数など）の使い方がわかるようにする。

人間に対する可読性も意識するとよい。

ライブラリのドキュメントをイメージしてもらうとわかりやすいです。
たとえば[underscore.jsのドキュメント](https://underscorejs.org/#arrays)を見てみると、関数ごとに入力の例とそれに対する出力が書かれている。こういうの。

![image.png](attachment:a6d213da-0583-448a-94b7-43fa3779d383:image.png)

> **first**`_.first(array, [n])` *Aliases: **head**, **take*** [source](https://underscorejs.org/docs/modules/first.html)
> 
> 
> Returns the first element of an **array**. Passing **n** will return the first **n** elements of the array.
> 
> ```
> _.first([5, 4, 3, 2, 1]);
> => 5
> ```
> 

「こういう引数を与えて実行したらこれが返ってきます」というスタイル、これってそのままテストの書き方みたいですよね。ドキュメントとテストって実質同じなんです。

```tsx
describe('first', function() {
  it('配列の先頭の要素を返す (Returns the first element of an array.)', function() {
    expect(_.first([5, 4, 3, 2, 1])).toBe(5);
  });
});
```

テストを十分に書いておくと、わざわざ追加のコメントやドキュメントで「こういう値を入れてください」とか「こういう値が返ってきます」とか書く必要が少なくなる。しかも、そういう説明を書いたコメントは腐る（実装が変わったのにコメントが更新されない）ことが多い。

一方、テストは機械的に実行され、実装の変更に追従していない場合エラーとして検出できる。

質問

（石橋さん）

- テストコードが多くなってくると、ケース同士でデータを流用するか？
    
    →実行順によってテストが落ちたら困ったり、依存関係が発生したりで困るのでケースでデータを共有しない方が理想かも？
    
    ⇔ただ、流用しない場合にテストを書く量が多くなる
    
    一個ずつ reset する方が本来は運用しやすそうだけど、テストの実行時間が長くなっちゃうかな
    
    →やがさきさん：トータルのバランス見て決めるのがいいかも、実行時間問題は並列実行して回避とかもできるし・・・
    
- テストコードが多くなってくると読みづらいけど、いい感じに扱う方法はないか？
    - VSCode は Outline のタブで見ると見やすいかも
