---
title: "原則 4. 堅牢 (Robust) を読んでみよう"
---

## 原則 4. 堅牢 (Robust) とは

>コンテンツは、支援技術を含む様々なユーザエージェントが確実に解釈できるように十分に堅牢 (robust) でなければならない。
>https://waic.jp/translations/WCAG21/#robust

**どんな環境でも、いつになっても、Webページが壊れないように（ブラウザが正しく表示できるように）作りましょう。**

そもそも「堅牢（Robust、ロバスト）」ってどういう意味なんでしょう。
超簡単にいえば「丈夫」とか「壊れにくい」的なことだそうです。
情報工学では、「外れ値が入っても壊れない」などのこと。
https://ja.wikipedia.org/wiki/%E3%83%AD%E3%83%90%E3%82%B9%E3%83%88%E3%83%8D%E3%82%B9

語源は、オーク材が頑丈なことから、「オーク材の」を意味するラテン語から来ているそうです。
https://gogen-ejd.info/robust/

## ガイドライン 4.1: 互換性

>現在及び将来の、支援技術を含むユーザエージェントとの互換性を最大化すること。
>[ガイドライン 4.1: 互換性を理解する](https://waic.jp/translations/WCAG21/Understanding/compatible.html)

**どんな環境でも、いつになっても、動くようにしましょう。**

「Chromeでは動くけどSafariではどうかわかりません！」でもダメだし、「今は動くけど来年はどうかわかりません！」でもダメだし、「ブラウザでは動くけどスクリーンリーダーでは使えません！」もダメ。

###  4.1.1 構文解析 (レベル A)

> マークアップ言語を用いて実装されているコンテンツにおいては、要素には完全な開始タグ及び終了タグがあり、要素は仕様に準じて入れ子になっていて、要素には重複した属性がなく、どの ID も一意的である。ただし、仕様で認められているものを除く。
>[達成基準 4.1.1: 構文解析を理解する](https://waic.jp/translations/WCAG21/Understanding/parsing.html)

**正しいHTMLを書きましょう！** ただそれだけです。

具体的には以下を守りましょう。

- [x] **完全な** 開始タグと終了タグがある。
  - 山カッコ（`>`）が欠けていたりとか、引用符（`"`）が対応していなかったりすると、「完全な」ではなくなる。
- [x] 要素の入れ子ルールを守っている。
- [x] 一つの要素に重複した属性を設定していない。
- [x] ページ内でidを一意にする。

「ちょっとくらい間違っていても、ブラウザで表示できたからOK！」と思うこともあるかもしれません。
ですが、その裏では、ブラウザが正しくないHTMLを「まあこういうことだろうな」と「修復」して表示しています。
この修復方法はブラウザによって違うので、あるブラウザで正しく表示できたからと言って、他のブラウザでも表示できるとは限りません。
だから、どんなブラウザでも正しく表示される「丈夫さ」のために、正しいHTMLを書きましょう。

具体的には、 [Nu Html Checker](https://validator.w3.org/nu/) のようなバリデーターを使用して確認しましょう。
コーディング時には、 [Markuplint](https://markuplint.dev/ja/) のようなリンターを使って、自動的にチェックするようにしましょう。

---

……なんですが、この達成基準は WCAG 2.2 （次のバージョン）では、削除されようとしています。

https://www.mitsue.co.jp/knowledge/blog/a11y/202212/12_0923.html

昔は間違ったHTMLに対する修復方法がブラウザによって違っていたので、この達成基準が必要でしたが、現在ではHTML Standardによってエラーの修復方法が規定されたためとのことです。

###  4.1.2 名前 (name)・役割 (role) 及び値 (value) (レベル A)

リンク、ボタン、フォームなどの、機能の部分に関する話です。

> すべてのユーザインタフェース コンポーネント (フォームを構成する要素、リンク、スクリプトが生成するコンポーネントなど) では、名前 (name) 及び役割 (role) は、プログラムによる解釈が可能である。又、状態、プロパティ、利用者が設定可能な値はプログラムによる設定が可能である。そして、支援技術を含むユーザエージェントが、これらの項目に対する変更通知を利用できる。
> [達成基準 4.1.2: 名前 (name)・役割 (role) 及び値 (value) を理解する](https://waic.jp/translations/WCAG21/Understanding/name-role-value.html)

**操作する（クリックしたり、入力したりする）部分の機能がブラウザに伝わるようにしましょう。**

この達成基準の理解には、WAI-ARIAの理解も必要になってきます。
それぞれ確認していきましょう。

#### 名前 (name)

**名前** は、WAI-ARIAの用語で **「アクセシブルな名前」** とも呼ばれます。スクリーンリーダーに読み上げられる名前です。
リンクであればリンクテキスト、ボタンであればボタンのラベルがそれにあたります。

```html
<!-- 「Zenn」がアクセシブルな名前 -->
<a href="https://zenn.dev/">Zenn</a>

<!-- 「メニューを開く」がアクセシブルな名前 -->
<button>メニューを開く</button>
```

`input` 要素では、紐付けられた `label` 要素のテキストがアクセシブルな名前になります。

```html
<!-- 「利用規約に同意します」がアクセシブルな名前 -->
<input type="checkbox" id="checkbox1">
<label for="checkbox1">利用規約に同意します</label>
```

ボタンをアイコンで表現している場合など、テキストがない場合は `aria-label` 属性を利用して、別途アクセシブルな名前を与えることができます。

```html
<button aria-label="メニューを開く"><svg>...</svg></button>
```

アクセシブルな名前がないと、そのリンクやボタンをクリックすると何が起こるのか伝わりません。フォームの入力欄であれば、何を入力したらいいのかわかりません。

#### 役割 (role)

**役割**　(role、ロール) は、「これはボタンですよー」とか「リンクですよー」とか「チェックボックスですよー」とかを伝えるものです。
ロールは、WAI-ARIAで定義されています。

https://www.w3.org/TR/wai-aria-1.2/#role_definitions

HTML要素には、それぞれ **暗黙のロール** というものがあり、自動的に決まります。

```html
<!-- hrefつきのa要素の暗黙のロールはlinkロール。この要素はlinkロールとしてブラウザに伝わる -->
<a href="https://zenn.dev/">Zenn</a>

<!-- button要素の暗黙のロールはbuttonロール。この要素はbuttonロールとしてブラウザに伝わる -->
<button>メニューを開く</button>

<!-- input[type="checkbox"]の暗黙のロールはcheckboxロール。この要素はcheckboxロールとしてブラウザに伝わる -->
<input type="checkbox" id="checkbox1">
<label for="checkbox1">利用規約に同意します</label>
```

どうしてもHTML要素では表現できない場合、`role` 属性を利用して、役割を明示することができます。
ただし、 `role` 属性は、どうしてもHTML要素では表現できない場合に利用しましょう。

```html
<span role="button">これはボタンですよー</span>
```

役割が伝わると、それをスクリーンリーダーが読み上げることができます。
`Zenn リンク` とか `メニューを開く ボタン` とか `利用規約に同意します チェックボックス` といった具合に、役割が合わせて読み上げられるので、どんな動作が起こるのかがわかります。

#### 値 (value)

**値** には結構いろんなものが含まれます。
例えば以下のようなものです。

- フォーカスを受け取るかどうか（プロパティ）
- フォーカスされているかどうか（状態）
- アコーディオンの開閉ボタンが開いているかどうか（状態）
- チェックボックスがチェックされているかどうか（状態）
- テキストボックスに入力されているテキスト（利用者が設定可能な値）

これらも、HTML要素を適切に使用していれば正しく伝わります。

```html
<!-- フォーカスを受け取ることができる -->
<button>ボタン</button>

<!-- アコーディオンの開閉ボタンが開いているかどうかの状態が伝わる -->
<details open>
  <summary>詳細を見る</summary>
  詳細なコンテンツ
</details>
```

例えば「フォーカスを受け取るかどうか」は `tabindex` 属性を付けることでも伝えることができますが、基本的には `button` や `a` などを使用すべきです。

---

これまでに見てきた通り、HTML要素を正しく使っていれば、ブラウザ・支援技術は名前・役割・値を正しく理解できます。
主にこれを考慮するのは、自前で実装するようなときです。

>この達成基準は、主に独自のユーザインタフェース コンポーネントを開発、又はスクリプトで実装するコンテンツ制作者に向けたものである。例えば、標準的な HTML のコントロールを仕様に沿って使用していれば、既にこの達成基準を満たしていることになる。


#### 確認方法

Devtoolsで「アクセシビリティツリー」を確認すると、どのようにブラウザに伝わっているかを確認することができます。
要素 (Elements) タブ内の アクセシビリティ (Accessibility) タブに表示されます。

https://zenn.dev/yusukehirao/books/1ec099b9717588/viewer/acab21



### 4.1.3 ステータスメッセージ (レベル AA)

> マークアップ言語を使って実装されたコンテンツでは、ステータスメッセージは、役割 (role) 又はプロパティを通してプログラムによる解釈が可能であり、フォーカスを受けとらなくても支援技術によってユーザに提示することができる。
> [達成基準 4.1.3: ステータスメッセージを理解する](https://waic.jp/translations/WCAG21/Understanding/status-messages.html)

**ステータスメッセージ（通知や状態の変化）が、スクリーンリーダーでも伝わるようにしましょう。**

ステータスメッセージとは、「エラーが発生しましたよ！」とか、「処理が終わりましたよ！」とか、状態が変わったことを伝えるやつ。以下のようなものです。

- フォームの入力内容が正しくないときに表示される、「名前は必須です」とか「メールアドレスは正しい形式で入力してください」とかの**エラーメッセージ**
- 検索・絞り込みを行ったときに表示される「検索結果は 10 件です」とか「絞り込み条件に該当する結果はありませんでした」とかの**実行結果表示**
- SNSでメッセージを送信したときに表示される「送信が完了しました」みたいな**通知**

目で見ているユーザーには、画面内に結果や通知が出現することで知らせることができます。
フォームのエラーメッセージや検索結果は、ふつう送信ボタンや検索ボタンの近くに表示され、目に入ります。
送信完了の通知などは、スナックバーのようなもので画面の上部や隅に表示されることが多いです。

ですが、スクリーンリーダーユーザーに対してはどうでしょうか。
目に入る、なんてことはありませんから、他のものより優先して読み上げさせるように実装する必要があります。

具体的な実装のためには、WAI-ARIAの仕様を理解する必要があります。
WAI-ARIAには、「スクリーンリーダーがすぐに内容を読み上げる」ための方法があります。
[ライブリージョン](https://developer.mozilla.org/ja/docs/Web/Accessibility/ARIA/ARIA_Live_Regions)と呼ばれます。

HTML要素の中にはデフォルトでライブリージョンとして機能するものがあります。それは `output`要素です。
次のように、`output`要素で検索結果の出力をマークアップすると、件数が変更されたときにスクリーンリーダーが読み上げてくれます。

```html:output要素を使用した場合
<output>
  検索結果は <span id="result-count">10</span> 件です
</output>
```

ステータスメッセージの読み上げのためにはまずは `output` 要素を使う、と一旦理解してもらえばよいかと思いますが、ARIAの詳しい仕様について以下にまとめます。

:::details ライブリージョンに関するWAI-ARIA仕様を詳しく

#### aria-live

ステータスメッセージの読み上げに必須のプロパティが `aria-live` です。
`aria-live="polite"` 属性を設定すると、その要素のテキストの変更が、フォーカスを移動しなくても読み上げられるようになります。 
`aria-live="assertive"` 属性を設定すると、今の読み上げに割り込んですぐに読み上げてくれます（濫用すると迷惑なので、こちらは本当に緊急の通知に使いましょう）。

#### ライブリージョン属性を含むロール

ARIAロールの中には、デフォルトで `aria-live` 属性を持つものがあります。

https://developer.mozilla.org/ja/docs/Web/Accessibility/ARIA/ARIA_Live_Regions#%E3%83%A9%E3%82%A4%E3%83%96%E3%83%AA%E3%83%BC%E3%82%B8%E3%83%A7%E3%83%B3%E5%B1%9E%E6%80%A7%E3%82%92%E5%90%AB%E3%82%80%E3%83%AD%E3%83%BC%E3%83%AB

`log` ロール、 `status` ロールは `aria-live="polite"` がデフォルトで設定されています。
`alert` ロールは `aria-live="assertive"` がデフォルトで設定されています。

HTMLの`output` 要素は暗黙のロールが `status`ロールであるため、ライブリージョンになります。

#### aria-atomic

読み上げの挙動を制御するためのプロパティです。
`aria-atomic="true"` 属性を設定すると、要素内のテキストが変更されたときに、その要素内のテキスト全体が読み上げられます。
`aria-atomic="false"` にすると、変更された部分だけが読み上げられます。

#### aria-relevant

どんな変更を通知するかを制御するためのプロパティです。
`aria-relevant="additions"` にすると、要素内のテキストが追加されたときに読み上げられます。
`aria-relevant="removals"` にすると、要素内のテキストが削除されたときに読み上げられます。
`aria-relevant="text"` にすると、要素内のテキストが変更されたときに読み上げられます。
デフォルトは `aria-relevant="additions text"` です。

https://developer.mozilla.org/ja/docs/Web/Accessibility/ARIA/ARIA_Live_Regions#%E5%9F%BA%E6%9C%AC%E7%9A%84%E3%81%AA%E4%BE%8B_aria-relevant

:::


---

（これは私の感想ですが、）なぜこの達成基準が「堅牢」「互換性を保つ」に分類されるのかがよくわかりませんでした……。「理解可能」とかではないんですかね？
